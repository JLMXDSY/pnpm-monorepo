# 彻底搞懂原型链
### 为什么会有原型
- 原型就是为了节省内存资源浪费，把公共的方法属性放在原型上
    ```js
        var 军营 = []
        function 创建士兵(id,血量){
            var 士兵 = {}
            士兵.id=id,
            士兵.血量=血量,
            士兵.攻击力='100',
            士兵.兵种='空军'
            士兵.攻击=function(){/*呼他熊脸*/}，
            士兵.防御=function(){/*防脸*/}    
            return 士兵;
        }
        var 士兵信息字典 = [{id:'1',血量},{id:'2',血量},...,{id:'100',血量,90}]
        士兵信息字典.map(item=>{
            军营.push( 创建士兵(...item) )
        })
        // 上面这种工厂方式有一个缺点：浪费了很多内存，只有ID、血量是不一样的,没必要重复创建100次攻击函数、防御函数、兵种、攻击力
        var 军营 = []
        function 创建士兵(id,血量,攻击力){
            var 士兵 = {}
            士兵.id=id,
            士兵.血量=血量,
            士兵.攻击力=攻击力,  
            return 士兵;
        }
        创建士兵.prototype = {
            兵种:空军
            攻击:function(){/*呼他熊脸*/}，
            防御:function(){/*防脸*/} 
        }
        var 士兵信息字典 = [{id:'1',血量,100,攻击力:1000},{id:'2',血量,80,攻击力:2000},...,{id:'100',血量,90,攻击力:999}]
        士兵信息字典.map(item=>{
            军营.push( 创建士兵(...item) )
        })
        // 上面这种原型继承的方式就优美了很多，我们再看看来至js之父的关怀，new关键字
        var function 创建士兵(id,血量,攻击力){
            this.id = id
            this.血量 = 血量
            this.攻击力 = 攻击力
        }
        创建士兵.prototype = {
            兵种:空军
            攻击:function(){/*呼他熊脸*/}，
            防御:function(){/*防脸*/} 
        }
        var 士兵信息字典 = [{id:'1',血量,100,攻击力:1000},{id:'2',血量,80,攻击力:2000},...,{id:'100',血量,90,攻击力:999}]
        士兵信息字典.map(item=>{
            军营.push( new 创建士兵(...item) )
        })
    ```
    <img src="https://pic2.zhimg.com/80/v2-7508e2814e9362256c11af76b1db646d_1440w.jpg" style="zoom:25%;"/>


- 构造函数

    所有函数只要用new 来调用就是构造函数，也就是说，所有的函数都有可能要在原型上创建一些公共的属性和方法，以便将来创建的实例对象可以拥有这些属性和方法，而不是重复创建
    这也解释了一句常见的话
    <b style="color:red">[所有的函数都有prototype属性，而所有的实例对象都可以通过__proto__访问到构造函数的原型]</b>

    ```
    [[prototype]] 就是__proto__ ,__proto__是浏览器非标准的实现，js中对象调用一个属性，会先从自身找，找不到会通过[[prototype]]继续在构造函数的原型上找，直到[[prototype]]为null停止，这就是原型链
    所以这块我们理解：__pooto__的本质就是找到实例对象的构造函数的原型
    ```
    ```
    也不是所有的函数都有prototype属性，因为js最底层的function是一个匿名函数【实际上是一个对象】，而且不可以被new ,所以没有prototype
    ```

    ```
    最难理解的一块儿内容：
    实例对象是没有prototype属性的，
    所有的函数都是由Function构造的，包括Function自身，所以Function同时作为函数和对象既有prototype也有[[prototype]],
    而且Function的原型(Function.prototype)就是最底层的那个匿名函数(ƒ anonymous())，不可以被new，所以没有prototype,
    值得注意的是：最底层的那个匿名函数(ƒ anonymous())自身定义了一个constructor(定义的这个构造函数又指向了Function)覆盖了[[prototype]]指向的构造函数的原型对象里的constructor(Object)
    这个时候:实例对象.__proto__===实例对象.constructor.prototype就不适用了
    ```
    ```js
    console.log(Function.prototype.__proto__ ===Function.prototype.constructor.prototype)//false
    ```
- 为什么js要在最底层的那个匿名函数(ƒ anonymous())自身定义一个constructor(定义的这个构造函数又指向了Function)覆盖[[prototype]]指向的构造函数的原型对象里的constructor(Object)

    暂时推测：为了统一所有的函数都是由Function来构造的，而实际函数又得有对象得特性

- 接下来讨论一下constructor

    constructor:构造器
    在上面说了对象的[[prototype]]指向了实例的构造函数的原型对象，那么实例的构造函数是怎么指向的？
    假设我们在实例对象上都定义一个constructor来指向它的构造函数，显然不合适，这是个公共属性，应该放到原型上，所以只有在实例对象的构造函数原型对象上才会有constructor属性，控制台打印一下
    这也是为什么尽量不要用f.prototype = {a:3,b:4}这种方式给原型赋值，会丢掉constructor的
    // 有下面两种方式给原型赋值
   1. 	f.prototype.a = 3 
   		f.prototype.b = 4
   2.  f.prototype = {
     		constructor:f,
     		a:3,
     		b:4
   		}
    var o = {}可以看看
    直接读取o.constructor就可以从原型上读取到，除非自定义属性constructor覆盖了原型上的
- 总结

    最后总结一句话：研究原型链只需要关注[[prototype]],不关注prototype,因为prototype只是为了在new一个函数的时候可以为实例对象在原型上添加公共属性和方法，其他没有任何卵用

- [class](https://es6.ruanyifeng.com/#docs/class)
    JavaScript 语言中，生成实例对象的传统方法是通过构造函数
    ```js
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }
    
    Point.prototype.toString = function () {
      return '(' + this.x + ', ' + this.y + ')';
    };
    
    var p = new Point(1, 2);
    ```
    ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。
    ```js
    class Point {
      constructor(x, y) {
        // 这是构造函数得内容，this就是实例对象，所以必须显示定义this.xxx才会是实例自己得属性，否则都是class即原型上得属性
        this.x = x;
        this.y = y;
      }
       // 类得所有方法都定义在类得prototype上，注意：类方法中的this默认指向类的实例
      toString() {
        return '(' + this.x + ', ' + this.y + ')';
      }
    }
    // 这两行代码证明类本身就是构造函数
    typeof Point // "function"
    Point === Point.prototype.constructor // true
    // 和构造函数一样，类也是通过new实例化一个对象，且类必须使用new调用，否则会报错，这是它跟普通构造函数的一个主要区别。
    let point = new Point(100,100)
    // 注意：类的内部所有定义的方法，都是不可枚举的，这和构造函数得行为不一致
    Object.keys(Point.prototype)
    // []
    Object.getOwnPropertyNames(Point.prototype)
    // ["constructor","toString"]
    ```
不写了去看阮一峰大神的文档吧，自己就搞懂原型继承就很好去看懂了